<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>The &#8216;Contour/Image Plot Options&#8217; Interface</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,frames,3 --> 
<meta name="src" content="QubistHTML.tex"> 
<meta name="date" content="2012-02-01 01:22:00"> 
<link rel="stylesheet" type="text/css" href="QubistHTML.css"> 
</head><body 
>
<!--l. 3547--><div class="crosslinks"><p class="noindent">[<a 
href="QubistHTMLse35.html" >next</a>] [<a 
href="QubistHTMLse33.html" >prev</a>] [<a 
href="QubistHTMLse33.html#tailQubistHTMLse33.html" >prev-tail</a>] [<a 
href="#tailQubistHTMLse34.html">tail</a>] [<a 
href="QubistHTMLch5.html#QubistHTMLse34.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">5.4   </span> <a 
 id="x53-770005.4"></a>The &#8216;Contour/Image Plot Options&#8217; Interface</h3>
<a 
 id="dx53-77001"></a>
<!--l. 3551--><p class="noindent" >The optimal set generated by Ferret can be thought of as scattered data that is represented by a set of points in an
(<span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">par</span></sub> + <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">obj</span></sub>)-dimensional space, where <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">par</span></sub> is the number of parameters and <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">obj</span></sub> is the number of objectives.
These points are viewed as a scatter plot by default, but Ferret can also represent them as an image or contour plot,
which smoothes out the data and sometimes makes the distribution of points easier to see. This is especially useful
when your solution set contains a large number of points, since scatter plots can become confusing when the
individual points start to overlap.
<!--l. 3553--><p class="noindent" >To create an image or contour plot from the scattered point data in an OptimalSolutions structure, Qubist
constructs a two-dimensional projection of the points, and then bins them onto a regular grid. The &#8216;Contour/Image
Plot Options&#8217; interface, shown in Figure <a 
href="#x53-770026">5.6<!--tex4ht:ref: fig:imageOptions --></a> is a set of controls that can be used to control this binning and modify
the appearance of two-dimensional image and contour plots that are displayed in the analysis window. Ferret&#8217;s
Z-Axis menu controls which parameter or objective is represented by the colour or shading level of an image plot, or
by contours for a contour plot. <hr class="figure"><div class="figure" 
>
                                                                                         

                                                                                         
<a 
 id="x53-770026"></a>
                                                                                         

                                                                                         
<div class="center" 
>
<!--l. 3555--><p class="noindent" >

<!--l. 3556--><p class="noindent" ><img 
src="figures/Ferret/imageOptions.png" alt="PIC"  
></div>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5.6: </span><span  
class="content">The &#8216;Contour/Image Plot Options&#8217; control panel shown here pops up whenever a plot option is
selected that requires a two-dimensional image or contour plot.</span></div><!--tex4ht:label?: x53-770026 -->
                                                                                         

                                                                                         
<!--l. 3560--><p class="noindent" ></div><hr class="endfigure">
<!--l. 3562--><p class="noindent" >The image options interface may seem quite complicated at first, but it will seem simpler once you have used it a
few times. It provides a great deal of flexibility in how your images are displayed, which helps to tease information
out of your optimal set or to prepare publication quality figures.
<a 
 id="dx53-77003"></a>
<!--l. 3565--><p class="noindent" >The slider and corresponding text box titled &#8216;Number of pixels for binning&#8217; controls the number of pixels used for
image and contour plots. If the slider value is set to a number <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">pix</span></sub>, then image and contour plots will be based on
an <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">pix</span></sub> <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">pix</span></sub> grid. This control is probably the most important one on the contour/image plot interface, and
the ability to see features in the optimal set hinges on choosing it well. The idea is to make the grid
coarse enough (sufficiently small NPix) that the image or contour plot looks smooth and well filled
in, but fine enough (sufficiently large <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">pix</span></sub>) to minimize information loss due to over-smoothing the
image. Generally, larger values of <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">pix</span></sub> are appropriate for large optimal sets, while smaller values
are required to fill in gaps between points when the optimal set is small. Usually, I just try various
settings until I get the visual effect that I&#8217;m looking for. Panel a) of Figure <a 
href="QubistHTMLse32.html#x51-750253">5.3<!--tex4ht:ref: fig:plotOptions --></a> shows an image plot
with points shaded according to the logarithm of <span 
class="cmmi-10">&#x03C7;</span><sub><span 
class="cmmi-7">reduced</span></sub><sup><span 
class="cmr-7">2</span></sup> for our binary star modeling example.
Logarithmic scaling does a better job of highlighting the &#8216;spine&#8217; of the curve than linear scaling or scatter
plots.
<a 
 id="dx53-77004"></a>
<!--l. 3568--><p class="noindent" >For contour plots, the number of contours can be specified using the slider or textbox labelled &#8216;Number of
contour levels / Specific contour levels&#8217;. A small number of levels makes a filled contour plot look like it
has steps between levels, while a larger number tends to smooth out the plot. This control has no
effect on image plots. It is also possible to specify specific levels, which are plotted as heavy black or
white lines. These contour levels appear on <span 
class="cmti-10">any </span>two-dimensional view, including scatter plots (See the
top left panel of Figure <a 
href="QubistHTMLse32.html#x51-750304">5.4<!--tex4ht:ref: fig:binaryProjections --></a> for example), image plots, and the 2-D Combo plots. The contours are
labelled if the &#8216;Labels&#8217; radio button is selected. If either of the buttons labelled as &#8216;<span 
class="cmmi-10">min</span>+&#8217; or &#8216;<span 
class="cmmi-10">max</span><span 
class="cmsy-10">-</span>&#8217; are
selected, then the contour levels chosen are regarded as relative to either the minimum or maximum <span 
class="cmmi-10">z</span>
value in the current projection of the optimal set. For example, if a contour level 0.1 is chosen and
<span 
class="cmmi-10">min</span>+ is chosen, then the level actually contoured will be the minimum <span 
class="cmmi-10">z </span>value plus 0.1. If <span 
class="cmmi-10">max</span><span 
class="cmsy-10">- </span>is
chosen, then the maximum <span 
class="cmmi-10">z </span>value minus 0.1 will be the level that is contoured. Panels b) and c) of
Figure <a 
href="QubistHTMLse32.html#x51-750253">5.3<!--tex4ht:ref: fig:plotOptions --></a> show two contour plots of the same projection that are displayed using different colour
maps.
<!--l. 3570--><p class="noindent" >An image or contour plot bins and flattens the X-Y-Z values into two dimensions, and displays the Z-coordinate
using colours, shades, or contours. However, there is some choice in how these data are flattened. For example, you
could choose to represent the minimum value in each square bin or pixel, the maximum value, or the average <span 
class="cmmi-10">z </span>value
of all points that fall within that pixel. Other choices are also possible. For example, you could slice through the
points that fall within a particular pixel, and choose to average only the values below the slice, or above the slice, or
in both directions some distance on either side of the slice. My point is that real choices exist in how to
display these data, and your choice can strongly affect how well you can see features in the optimal
set.
<a 
 id="dx53-77005"></a>
<!--l. 3573--><p class="noindent" >Qubist uses a combination of data slicing and averaging to convert scattered three-dimensional data into a
two-dimensional image or contour plot. The third slider on the contour/image interface sets the value of a control
parameter called <span 
class="cmmi-10">sliceLevel</span>, which determines how the data are sliced. There are three radio buttons below this
slider, labelled &#8216;Valleys&#8217;, &#8216;Mean&#8217;, and &#8216;Peaks&#8217;, which determine how the data slicing is applied. The procedure used
in each case is discussed below:
                                                                                         

                                                                                         
     <ul class="itemize1">
     <li class="itemize">
     Valleys:
     Determine
     the
     extent
     of
     the
     data
     in
     the
     z-direction:
     &#x0394;<span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span></sub> = <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">min</span>(<span 
class="cmmi-10">z</span>).
     Apply
     a
     slice
     at
     certain
     fraction
     &#8216;sliceLevel&#8217;
     above
     the
     minimum:
     <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">slice</span></sub> = <span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span><span 
class="cmmi-7">,min</span></sub> + &#x0394;<span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span></sub> <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">sliceLevel</span>.
     Throw
     away
     all
     points
     above
     the
     cut,
     and
     keep
     the
     remaining
     points
     to
     display.
     All
     of
     the
     data
     points
     are
     included
     when
     <span 
class="cmmi-10">sliceLevel </span>= 1.
                                                                                         

                                                                                         
     </li>
     <li class="itemize">
     Peaks:
     Determine
     the
     extent
     of
     the
     data
     in
     the
     z-direction:
     &#x0394;<span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span></sub> = <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">min</span>(<span 
class="cmmi-10">z</span>).
     Apply
     a
     slice
     at
     certain
     fraction
     &#8216;sliceLevel&#8217;
     below
     the
     maximum:
     <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">slice</span></sub> = <span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span><span 
class="cmmi-7">,max</span></sub> <span 
class="cmsy-10">- </span>&#x0394;<span 
class="cmmi-10">z</span><sub><span 
class="cmr-7">0</span></sub> <span 
class="cmsy-10">&#x00D7; </span><span 
class="cmmi-10">sliceLevel</span>.
     Throw
     away
     all
     points
     below
     the
     cut,
     and
     keep
     the
     remaining
     points
     to
     display.
     All
     of
     the
     data
     points
     are
     included
     when
     <span 
class="cmmi-10">sliceLevel </span>= 0.
                                                                                         

                                                                                         
     </li>
     <li class="itemize">
     Mean:
     Find
     the
     average
     <span 
class="cmmi-10">z</span>
     value
     of
     points
     in
     the
     optimal
     set.
     Cut
     both
     above
     and
     below
     the
     mean
     level,
     using
     the
     &#8216;peaks&#8217;
     and
     &#8216;valleys&#8217;
     method
     discussed
     above.
     In
     this
     case,
     sliceLevel
     determines
     the
     width
     of
     the
     band
     about
     the
     mean.
     All
     of
     the
     data
                                                                                         

                                                                                         
     points
     are
     included
     when
     <span 
class="cmmi-10">sliceLevel </span>= 1.</li></ul>
<a 
 id="dx53-77006"></a>
<!--l. 3581--><p class="noindent" >The points that remain in each pixel after slicing must still be combined to determine an overall value for the pixel.
Once again, there is some choice in how this can be done. This is done by choosing a control parameter called the
<span 
class="cmmi-10">bias</span>. The most important consideration about the bias is that it is applied on a <span 
class="cmti-10">pixel-by-pixel </span>basis. This is in
contrast to the slicing operation, which cuts through the data set as a whole. The three choices for the bias are as
follows:
     <ul class="itemize1">
     <li class="itemize">
     bias
     =
     0:
     Return
     the
     mean
     value
     for
     each
     pixel.
     </li>
     <li class="itemize">
     bias
     <span 
class="cmmi-10">&#x003C;</span>
     0:
     For
     each
     pixel
     separately,
     determine
     the
     range
     &#x0394;<span 
class="cmmi-10">z</span>
     of
     values
     contributing
     to
     the
     pixel:
     &#x0394;<span 
class="cmmi-10">z </span>= <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">min</span>(<span 
class="cmmi-10">z</span>).
                                                                                         

                                                                                         
     Place
     a
     cut
     at
     some
     height
     a
     fraction
     equal
     to
     <span 
class="cmmi-10">bias</span>
     down
     from
     max(z):
     <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">cut</span></sub> = <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">-|</span><span 
class="cmmi-10">bias</span><span 
class="cmsy-10">|&#x00D7; </span>&#x0394;<span 
class="cmmi-10">z</span>.
     Return
     the
     mean
     value
     of
     points
     below
     the
     cut.
     </li>
     <li class="itemize">
     bias
     <span 
class="cmmi-10">&#x003E;</span>
     0:
     For
     each
     pixel
     separately,
     determine
     the
     range
     &#x0394;<span 
class="cmmi-10">z</span>
     of
     values
     contributing
     to
     the
     pixel:
     &#x0394;<span 
class="cmmi-10">z </span>= <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">min</span>(<span 
class="cmmi-10">z</span>).
     Place
     a
                                                                                         

                                                                                         
     cut
     at
     some
     height
     a
     fraction
     equal
     to
     <span 
class="cmmi-10">bias</span>
     up
     from
     min(z):
     <span 
class="cmmi-10">z</span><sub><span 
class="cmmi-7">cut</span></sub> = <span 
class="cmmi-10">max</span>(<span 
class="cmmi-10">z</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">bias </span><span 
class="cmsy-10">&#x00D7; </span>&#x0394;<span 
class="cmmi-10">z</span>.
     Return
     the
     mean
     value
     of
     points
     above
     the
     cut.</li></ul>
<!--l. 3588--><p class="noindent" >The following are a few common cases that are worth considering:
     <ul class="itemize1">
     <li class="itemize">
     If
     a
     user
     wants
     to
     plot
     the
     minimum
     value
     in
     each
     pixel,
     then
     &#8216;Valleys&#8217;
     should
     be
     chosen
     for
     data
     slicing,
                                                                                         

                                                                                         
     sliceLevel
     should
     be
     set
     to
     0,
     and
     bias
     should
     be
     set
     to
     -1.
     </li>
     <li class="itemize">
     If
     a
     user
     wants
     to
     plot
     the
     maximum
     value
     in
     each
     pixel,
     then
     &#8216;Peaks&#8217;
     should
     be
     chosen
     for
     data
     slicing,
     sliceLevel
     should
     be
     set
     to
     0,
     and
     bias
     should
     be
     set
                                                                                         

                                                                                         
     to
     1.
     </li>
     <li class="itemize">
     If
     a
     user
     wants
     to
     plot
     the
     mean
     value
     in
     each
     pixel,
     then
     &#8216;Mean&#8217;
     should
     be
     chosen
     for
     data
     slicing,
     sliceLevel
     should
     be
     set
     to
     0,
     and
     the
     bias
     should
     be
     set
     to
     0.</li></ul>
<!--l. 3595--><p class="noindent" >Other choices for the bias can be used to effectively smooth the data prior to image or contour plotting in order to
make figures look less noisy. For example, if we are viewing a plot in &#8216;Valleys&#8217; mode and set <span 
class="cmmi-10">bias </span>= <span 
class="cmsy-10">-</span>1, then the
image is shaded by using only the minimum <span 
class="cmmi-10">z </span>value of the points within each pixel. The resulting image
can look quite noisy, since only a single value (the minimum) is actually used to compute the overall
value for each pixel. On the other hand, if we set the <span 
class="cmmi-10">bias </span>to a slightly higher value, say -0.9, then
multiple points near the minimum value will be averaged to compute the displayed shade of each
pixel. Averaging tends to smooth out noise, and as a result, the image will appear smoother in most
cases.
                                                                                         

                                                                                         
<a 
 id="dx53-77007"></a>
<a 
 id="dx53-77008"></a>
<a 
 id="dx53-77009"></a>
<a 
 id="dx53-77010"></a>
<!--l. 3601--><p class="noindent" >The panel labeled as &#8216;Colour Scale&#8217; controls the colour map for the image. There are two vertical sliders that control
the colors assigned to the minimum and maximum <span 
class="cmmi-10">z </span>values of pixels. These can be used to adjust the contrast of the
image, or even to reverse the colour scheme if the slider on the left is placed higher than the slider on the right.
There is a toggle button labeled as &#8216;Log&#8217; below the sliders. When this is pushed in, a logarithmic stretch
is applied to the data before it is shaded. Logarithmic stretches are useful when the <span 
class="cmmi-10">z </span>values of the
pixels have a large dynamic range. This panel also contains a pop-up menu that allows you to select
between most of the colour maps that are available in MATLAB. It is set to MATLAB&#8217;s bluish-gray
&#8216;bone&#8217; colour map by default, which I think looks good with the Qubist interface, but feel free to
experiment.
<!--l. 3603--><p class="noindent" ><span 
class="cmti-10">Note that changes made using the plot options interface do not take effect until the user presses the &#8216;Re-Draw&#8217;</span>
<span 
class="cmti-10">button in the &#8216;Actions&#8217; panel.  </span>The reason for this delayed action is to avoid unnecessary and sometimes
time-consuming re-binning and re-rendering of plots until all changes have been made. The only exception is for
changes to the colour map, which take effect immediately because no re-binning of data is required. Note that this
interface keeps track of default settings. At any time, the user can revert to defaults or set new ones, using the
&#8216;Reset&#8217; and &#8216;Set Defaults&#8217; buttons. The &#8216;Cancel&#8217; button closes the plot options interface without applying any
changes.
<a 
 id="dx53-77011"></a>
                                                                                         

                                                                                         
<!--l. 3608--><div class="crosslinks"><p class="noindent">[<a 
href="QubistHTMLse35.html" >next</a>] [<a 
href="QubistHTMLse33.html" >prev</a>] [<a 
href="QubistHTMLse33.html#tailQubistHTMLse33.html" >prev-tail</a>] [<a 
href="QubistHTMLse34.html" >front</a>] [<a 
href="QubistHTMLch5.html#QubistHTMLse34.html" >up</a>] </p></div>
<!--l. 3608--><p class="noindent" ><a 
 id="tailQubistHTMLse34.html"></a>  
</body></html> 
